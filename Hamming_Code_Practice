{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/bbutka/CEC220/blob/main/Hamming_Code_Practice\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 16,
      "metadata": {
        "id": "ImZIZvk7TNFM",
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "outputId": "11e61bc0-4dac-457c-b210-0f9d7f5a9b61"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Enter a binary number (4 to 11 bits): 1011001\n",
            "\n",
            "Bit position:  7  6  5  4  3  2  1\n",
            "Data bits:     1  0  1  1  0  0  1\n",
            "\n",
            "Transmitted bit positions: 11 10  9  8  7  6  5  4  3  2  1\n",
            "Transmitted data bits:      1  0  1  P  1  0  0  P  1  P  P\n",
            "\n",
            "Parity bit P1 calculation:\n",
            "Bit positions used:  3  5  7  9 11 13 15\n",
            "Values used:         1  0  1  1  1  2  2\n",
            "P1 = 1\n",
            "\n",
            "Parity bit P2 calculation:\n",
            "Bit positions used:  3  6  7 10 11 14 15\n",
            "Values used:         1  0  1  0  1  2  2\n",
            "P2 = 0\n",
            "\n",
            "Parity bit P4 calculation:\n",
            "Bit positions used:  5  6  7 12 13 14 15\n",
            "Values used:         0  0  1  2  2  2  2\n",
            "P4 = 1\n",
            "\n",
            "Transmitted bit positions: 11 10  9  8  7  6  5  4  3  2  1\n",
            "Transmitted data bits:      1  0  1  0  1  0  0  1  1  0  1\n",
            "Enter the bit position (1 to 11) to flip (or 0 for no error): 7\n",
            "\n",
            "Received data after flipping the bit:\n",
            "\n",
            "Transmitted bit positions: 11 10  9  8  7  6  5  4  3  2  1\n",
            "Transmitted data bits:      1  0  1  0  0  0  0  1  1  0  1\n",
            "\n",
            "Check parity bit P1 calculation:\n",
            "Bit positions used:  1  3  5  7  9 11\n",
            "Values used:         1  1  0  0  1  1\n",
            "P1 = 0\n",
            "\n",
            "Check parity bit P2 calculation:\n",
            "Bit positions used:  2  3  6  7 10 11\n",
            "Values used:         0  1  0  0  0  1\n",
            "P2 = 0\n",
            "\n",
            "Check parity bit P4 calculation:\n",
            "Bit positions used:  4  5  6  7\n",
            "Values used:         1  0  0  0\n",
            "P4 = 1\n",
            "\n",
            "Check parity bit P8 calculation:\n",
            "Bit positions used:  8  9 10 11\n",
            "Values used:         0  1  0  1\n",
            "P8 = 0\n",
            "\n",
            "Error detected at bit position: 4\n",
            "\n",
            "Corrected received bits:\n",
            "\n",
            "Transmitted bit positions: 11 10  9  8  7  6  5  4  3  2  1\n",
            "Transmitted data bits:      1  0  1  0  0  0  0  0  1  0  1\n",
            "\n",
            "Corrected data bit positions:  7  6  5  4  3  2  1\n",
            "Corrected data bits:           1  0  1  0  0  0  1\n"
          ]
        }
      ],
      "source": [
        "# Function to check if the input is a valid binary number of length between 4 and 11 bits\n",
        "def check_binary_validity(binary_num):\n",
        "    return len(binary_num) in range(4, 12) and all(bit in '01' for bit in binary_num)\n",
        "\n",
        "# Function to store binary bits in a list with LSB on the right\n",
        "def store_binary_bits(binary_num):\n",
        "    bit_storage = [2] * 11\n",
        "    for i, bit in enumerate(reversed(binary_num)):\n",
        "        bit_storage[i] = int(bit)\n",
        "    return bit_storage\n",
        "\n",
        "# Function to calculate parity bits\n",
        "def calculate_parity_bits(transmitted_with_zeros, bit_length):\n",
        "    parity_positions = [0, 1, 3]\n",
        "    if bit_length >= 8:\n",
        "        parity_positions.append(7)\n",
        "    dependencies = {\n",
        "        0: [i for i in range(15) if (i + 1) & 1 and i != 0],\n",
        "        1: [i for i in range(15) if (i + 1) & 2 and i != 1],\n",
        "        3: [i for i in range(15) if (i + 1) & 4 and i != 3],\n",
        "        7: [i for i in range(15) if (i + 1) & 8 and i != 7]\n",
        "    }\n",
        "    parity_bits = {}\n",
        "    for p in parity_positions:\n",
        "        parity_sum = sum(transmitted_with_zeros[i] for i in dependencies[p] if i < bit_length + len(parity_positions))\n",
        "        parity_bits[p] = parity_sum % 2\n",
        "        print_parity_info(p + 1, [i + 1 for i in dependencies[p]], transmitted_with_zeros, parity_bits[p])\n",
        "    return parity_bits\n",
        "\n",
        "# Function to print parity bit calculation details\n",
        "def print_parity_info(parity_pos, used_bits, transmitted_with_zeros, parity_value):\n",
        "    used_bits_str = ' '.join(f\"{i:2}\" for i in used_bits)\n",
        "    values_used_str = ' '.join(f\"{transmitted_with_zeros[i-1]:2}\" for i in used_bits)\n",
        "    print(f\"\\nParity bit P{parity_pos} calculation:\")\n",
        "    print(f\"Bit positions used: {used_bits_str}\")\n",
        "    print(f\"Values used:        {values_used_str}\")\n",
        "    print(f\"P{parity_pos} = {parity_value}\")\n",
        "\n",
        "# Function to display binary bits\n",
        "def display_bits(binary_num, bit_storage):\n",
        "    bit_length = len(binary_num)\n",
        "    bit_positions = ' '.join(f\"{i:2}\" for i in range(bit_length, 0, -1))\n",
        "    data_bits = ' '.join(f\"{bit_storage[i-1]:2}\" for i in range(bit_length, 0, -1))\n",
        "    print(f\"\\nBit position: {bit_positions}\")\n",
        "    print(f\"Data bits:    {data_bits}\")\n",
        "\n",
        "# Function to create transmitted data with 'P' in parity positions\n",
        "def create_transmitted_with_P(bit_storage):\n",
        "    transmitted = [\"P\"] * 15\n",
        "    data_index = 0\n",
        "    for i in range(15):\n",
        "        if i not in [0, 1, 3, 7]:\n",
        "            if data_index < len(bit_storage):\n",
        "                transmitted[i] = bit_storage[data_index]\n",
        "                data_index += 1\n",
        "    return transmitted\n",
        "\n",
        "# Function to display transmitted data with 'P' in parity positions\n",
        "def display_transmitted_with_P(transmitted, bit_length):\n",
        "    max_bit = 3 + bit_length if bit_length < 5 else 4 + bit_length\n",
        "    bit_positions = ' '.join(f\"{i:2}\" for i in range(max_bit, 0, -1))\n",
        "    data_bits = ' '.join(f\"{transmitted[i-1]:2}\" if transmitted[i-1] != \"P\" else \" P\" for i in range(max_bit, 0, -1))\n",
        "    print(f\"\\nTransmitted bit positions: {bit_positions}\")\n",
        "    print(f\"Transmitted data bits:     {data_bits}\")\n",
        "    transmitted_with_zeros = [0 if bit == \"P\" else bit for bit in transmitted]\n",
        "    return max_bit, transmitted_with_zeros\n",
        "\n",
        "# Function to create transmitted data with calculated parity bits\n",
        "def create_transmitted(transmitted_with_zeros, parity_bits):\n",
        "    transmitted = transmitted_with_zeros[:]\n",
        "    for pos, value in parity_bits.items():\n",
        "        transmitted[pos] = value\n",
        "    return transmitted\n",
        "\n",
        "# Function to display transmitted data\n",
        "def display_transmitted(transmitted, bit_length):\n",
        "    max_bit = 3 + bit_length if bit_length < 5 else 4 + bit_length\n",
        "    bit_positions = ' '.join(f\"{i:2}\" for i in range(max_bit, 0, -1))\n",
        "    data_bits = ' '.join(f\"{transmitted[i-1]:2}\" for i in range(max_bit, 0, -1))\n",
        "    print(f\"\\nTransmitted bit positions: {bit_positions}\")\n",
        "    print(f\"Transmitted data bits:     {data_bits}\")\n",
        "    return max_bit\n",
        "\n",
        "# Function to flip a specified bit\n",
        "def flip_bit(transmitted, bit_pos):\n",
        "    transmitted[bit_pos - 1] ^= 1\n",
        "    return transmitted\n",
        "\n",
        "# Function to check parity and detect errors\n",
        "def check_parity(transmitted, max_bits):\n",
        "    parity_positions = [0, 1, 3, 7] if max_bits >= 8 else [0, 1, 3]\n",
        "    dependencies = {\n",
        "        0: [i for i in range(15) if (i + 1) & 1],\n",
        "        1: [i for i in range(15) if (i + 1) & 2],\n",
        "        3: [i for i in range(15) if (i + 1) & 4],\n",
        "        7: [i for i in range(15) if (i + 1) & 8]\n",
        "    }\n",
        "    error_position = 0\n",
        "    for p in parity_positions:\n",
        "        parity_sum = sum(transmitted[i] for i in dependencies[p] if i < max_bits)\n",
        "        parity_value = parity_sum % 2\n",
        "        error_position += p + 1 if parity_value != 0 else 0\n",
        "        used_bits_str = ' '.join(f\"{i+1:2}\" for i in dependencies[p] if i < max_bits)\n",
        "        values_used_str = ' '.join(f\"{transmitted[i]:2}\" for i in dependencies[p] if i < max_bits)\n",
        "        print(f\"\\nCheck parity bit P{p + 1} calculation:\")\n",
        "        print(f\"Bit positions used: {used_bits_str}\")\n",
        "        print(f\"Values used:        {values_used_str}\")\n",
        "        print(f\"P{p + 1} = {parity_value}\")\n",
        "    return error_position\n",
        "\n",
        "# Function to extract data bits from transmitted data\n",
        "def extract_data_bits(transmitted, bit_length):\n",
        "    data_positions = [i for i in range(15) if i not in [0, 1, 3, 7]]\n",
        "    data_bits = [transmitted[data_positions[i]] for i in range(bit_length)]\n",
        "    return list(reversed(data_bits))\n",
        "\n",
        "# Function to display corrected data bits\n",
        "def display_corrected_data(data_bits):\n",
        "    bit_length = len(data_bits)\n",
        "    bit_positions = ' '.join(f\"{i:2}\" for i in range(bit_length, 0, -1))\n",
        "    data_bits_str = ' '.join(f\"{bit:2}\" for bit in data_bits)\n",
        "    print(f\"\\nCorrected data bit positions: {bit_positions}\")\n",
        "    print(f\"Corrected data bits:          {data_bits_str}\")\n",
        "\n",
        "def main():\n",
        "    # Input binary number from the user\n",
        "    binary_num = input(\"Enter a binary number (4 to 11 bits): \")\n",
        "    if not check_binary_validity(binary_num):\n",
        "        print(\"Invalid binary number. Please enter a binary number with 4 to 11 bits.\")\n",
        "        return\n",
        "    bit_storage = store_binary_bits(binary_num)\n",
        "    bit_length = len(binary_num)\n",
        "    display_bits(binary_num, bit_storage)\n",
        "    transmitted_with_P = create_transmitted_with_P(bit_storage)\n",
        "    max_bit, transmitted_with_zeros = display_transmitted_with_P(transmitted_with_P, bit_length)\n",
        "    parity_bits = calculate_parity_bits(transmitted_with_zeros, bit_length)\n",
        "    transmitted = create_transmitted(transmitted_with_zeros, parity_bits)\n",
        "    display_transmitted(transmitted, bit_length)\n",
        "    error_bit = int(input(f\"Enter the bit position (1 to {max_bit}) to flip (or 0 for no error): \"))\n",
        "    if error_bit != 0:\n",
        "        transmitted = flip_bit(transmitted, error_bit)\n",
        "        print(\"\\nReceived data after flipping the bit:\")\n",
        "        display_transmitted(transmitted, bit_length)\n",
        "    error_position = check_parity(transmitted, max_bit)\n",
        "    if error_position == 0:\n",
        "        print(\"\\nNo Error\")\n",
        "    else:\n",
        "        print(f\"\\nError detected at bit position: {error_position}\")\n",
        "        transmitted = flip_bit(transmitted, error_position)\n",
        "        print(\"\\nCorrected received bits:\")\n",
        "        display_transmitted(transmitted, bit_length)\n",
        "    corrected_data_bits = extract_data_bits(transmitted, bit_length)\n",
        "    display_corrected_data(corrected_data_bits)\n",
        "\n",
        "# Ensure the main function is called when the script is run in Google Colab\n",
        "if __name__ == \"__main__\":\n",
        "    main()\n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNWCz5gAGO1BxNroqnSaIP7",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}